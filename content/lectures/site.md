+++
author = ["Mattox Beckman"]
draft = false
+++

## Videos {#videos}


### Line Sweep Convex Hull {#line-sweep-convex-hull}

<video id="my-video" controls preload="auto" width="720" data-setup="playbackRates: [0.5,1,1.5,2]">

<source type="video/mp4" src="/videos/LineSweepConvexHull.mp4"}></source>

</video>


### Line Sweep Closest Points {#line-sweep-closest-points}

<video id="my-video" controls preload="auto" width="720" data-setup="playbackRates: [0.5,1,1.5,2]">

<source type="video/mp4" src="/videos/LineSweepClosestPoints.mp4"}></source>

</video>


### Line Sweep Area of Union {#line-sweep-area-of-union}

<video id="my-video" controls preload="auto" width="720" data-setup="playbackRates: [0.5,1,1.5,2]">

<source type="video/mp4" src="/videos/LineSweepAreaOfUnion.mp4"}></source>

</video>


### Edit Distance Video {#edit-distance}

<video id="my-video" controls preload="auto" width="720" data-setup="playbackRates: [0.5,1,1.5,2]">

<source type="video/mp4" src="/videos/EditDistance.mp4"}></source>

</video>


## Docs {#docs}


### Why Take This Course? {#why-take-this-course}

Welcome to Competitive Programming!  In this class you will learn how to compete in programming contests such as ICPC,
Code Forces, and Hacker Rank.  **Is this class for you?  Read on to find out...**


#### What Are the Benefits of Competitive Programming? {#what-are-the-benefits-of-competitive-programming}

Participating in coding contests has benefits!

You will

-   build confidence in your coding skills,
-   increase your coding speed,
-   be ready to crush a coding interview,
-   and quite possibly make some friends!


#### But... I'm not very competitive, and besides, I'll never beat those top students! {#but-dot-dot-dot-i-m-not-very-competitive-and-besides-i-ll-never-beat-those-top-students}

That doesn't matter!  Whether you are just starting out or whether you are competing for a chance at the World Finals,
the only person you're really trying to beat is yourself.  The goal is to try hard, do a little bit better than last time,
or perhaps learn something that will help you next time.  You can do practice problems on your own, but there's nothing
like a contest to keep you honest.


#### Am I ready for this course? {#am-i-ready-for-this-course}

The only prerequisite is that we assume you know how to program.  We don't even assume you're any good at it... this course
will help with that part.  But if you have programmed in Python, C, or C++ then you are ready for this course.

It does help if you've taken data structures and a theory course... but you can get started now and take those later as you
get stronger.


### Getting Started {#getting-started}


#### How Do I Get Started? {#how-do-i-get-started}

-   Join the CampusWire forum.  If you registered before class started, you should have gotten an invite.  If you registered late,
    or did not get the invite, you need to email the instructor.
-   It is recommended that you get these books:
    -   [Competitive Programming 4](https://cpbook.net).  It is a two book set.
    -   [Guide to Competitive Programming](https://link.springer.com/book/10.1007/978-3-319-72547-5).  As of this writing the PDF is free.
-   Register on [Code Forces](https://codeforces.com).  Your username **will be visible** to other students; you can create a "throwaway"
    account if you want just for this course.
    -   Once you are registered, join [the class group](https://codeforces.com/group/C1FCILxvRp/contests).  This is where your problems
        will be hosted.
-   Also register on <https://vjudge.net>
    -   THe class group is at <https://vjudge.net/group/uiuc-cs491-sp23>


#### How do I get good at this? {#how-do-i-get-good-at-this}

Practice.  A lot.  But do it efficiently...

-   Attend contests as much as you can.
    -   [Code Forces](https://codeforces.com) has two hour long contests usually once or twice a week, for instance.
    -   After the contest is over, read the commentary, both for the problems you solved, and the problems you attempted and could not solve.
    -   Upsolve the ones you couldn't do.  (I don't know why they call it upsolving.)  This means that you go back to the computer, finish
        your solution, and submit it until you get it accepted.
-   Solve practice problems
    -   This has a similar feel, but in this case it's okay get help.  If you are solving UVa problems you can use the UDebug and UHunt
        sites for extra hints / sample inputs.


### Syllabus {#syllabus}


#### Location and Times {#location-and-times}

-   Course Title: Introduction to Competitive Programming
-   Rubric: CS 491 CAP
-   CRN: 31584
-   Dates: January 18th, 2023 to May 4th 2023
-   Time: 14:00 &amp;ndash; 14:50
-   Location: 2310 Everitt
-   Instructor: Mattox Beckman
-   Recommended Textbooks:
    -   [Competitive Programming 4](https://cpbook.org)
    -   [Guide to Competitive Programming](https://link.springer.com/book/10.1007/978-3-319-72547-5)
-   Prerequisites: ability to program is necessary; CS 225 strongly recommended.  We will use C++ for our content, but you are welcome to use
    a different language.
-   Office Hours: tba


#### Purpose {#purpose}

The purpose of this course is to prepare you to compete in ICPC-style competitive programming contests.  While this will help
you compete in the Illinois Programming League, Hacker Rank, Code Forces, or similar contests, learning this material has been shown
to help with programming assignments in other courses, and many students learn this material to become confident and skillful in coding
interviews.


#### Objectives and Outcomes {#objectives-and-outcomes}

Upon successfully completing this course, you will have solved many programming problems.  You will have learned to select the correct
algorithm depending on the problem constraints and available time and memory resources.  You will have learned to implement your
solutions quickly and accurately, being given minimal guidance if your solution is incorrect.  You will have learned to work on your own
and in an ICPC style team of students using one computer.  And hopefully you will have a lot of fun doing so!


#### Class Structure {#class-structure}

This is a flipped classroom.  You will be given a reading from the textbook, a short video to watch, and a sample problem or two to solve before class.
During class the instructor will ask for student comments about the problems and give commentary.   Afterward, there will be one or two more problems
for you to do during class.  Sometimes you will be asked to solve them individually, sometimes you will be placed in a team.  Once every two weeks we
will also release a problem set with a variety of problems to give you practice picking the correct algorithm to use.


#### Assignments and Grading {#assignments-and-grading}

This course is a Credit/No Credit course.  To get credit, you must complete 70% of the class-related problems, attend at least 70% of
the class sessions (or have made other arrangements), and complete six of the given bi-weekly
problem sets.  You may also get problem set credit by competing in an ICPC tryout or other significant externally held contest.

We will also have an assignment where you prepare a Team Reference Document.  This assignment is not required, but highly recommended.


#### Students with Disabilities {#students-with-disabilities}

To obtain disability-related academic adjustments and/or auxiliary aids,
students with disabilities must contact the course instructor as soon as
possible. To insure that disability-related concerns are properly
addressed from the beginning, students with disabilities who require
assistance to participate in this class should contact disability
resources and educational services
([DRES](https://www.disability.illinois.edu/)) and see the instructor
as soon as possible. If you need accommodations for any sort of
disability, please speak to me after class, or make an appointment to
see me, or see me during my office hours. DRES provides students with
academic accommodations, access, and support services. To contact DRES
you may visit 1207 S. Oak St., Champaign, call 333-4603 (v/tdd), or
e-mail a message to [disability@uiuc.edu](mailto:disability@uiuc.edu).


#### Emergency Response Recommendations {#emergency-response-recommendations}

The university police have posted some [emergency response recommendations](http://police.illinois.edu/emergency/). I
encourage you to review this website and the campus building
[floor plans website](http://police.illinois.edu/emergency-preparedness/building-emergency-action-plans/)
within the first 10 days of class.

Of course, since we're all online, your classroom is likely your living space.  Have you considered making
a fire safety plan with your family or roommates?


#### Family Educational Rights and Privacy Act (FERPA) {#family-educational-rights-and-privacy-act--ferpa}

Any student who has suppressed their directory information pursuant to family
educational rights and privacy act (FERPA) should self-identify to the
instructor to ensure protection of the privacy of their attendance in this
course. see the [FERPA](http://registrar.illinois.edu/ferpa) site for more information.


#### Mental Health {#mental-health}

Diminished mental health, including significant stress, mood changes, excessive
worry, substance/alcohol abuse, or problems with eating and/or sleeping can
interfere with optimal academic performance, social development, and emotional
wellbeing. The University of Illinois offers a variety of confidential services
including individual and group counseling, crisis intervention, psychiatric
services, and specialized screenings at no additional cost. If you or someone
you know experiences any of the above mental health concerns, it is strongly
encouraged to contact or visit any of the University's resources provided below.
Getting help is a smart and courageous thing to do -- for yourself and for those
who care about you.

Counseling Center: 217-333-3704, 610 East John Street Champaign, IL 61820

McKinley Health Center:217-333-2700, 1109 South Lincoln Avenue, Urbana, Illinois 61801


### Schedule {#schedule}

| Week | Date        | Lecture Topic / Objectives                                  |
|------|-------------|-------------------------------------------------------------|
| 1    | January 18  | [Course Introduction](#course-introduction)                 |
|      | January 20  | [IO](#io)                                                   |
| 2    | January 23  | [Standard Template Library](#standard-template-library)     |
|      | January 25  | [Complete Search](#complete-search)                         |
|      | January 27  | [Divide and Conquer](#divide-and-conquer)                   |
| 3    | January 30  | [Greedy Algorithms](#greedy-algorithms)                     |
|      | February 1  | [Dynamic Programming](#dynamic-programming)                 |
| 5    | February 13 | [Graph Representations](#graph-representations)             |
| 6    | February 20 | [Single Source Shortest Path](#single-source-shortest-path) |
|      | February 22 | [All Points Shortest Path](#single-source-shortest-path)    |
|      | February 24 | [Traversals 2](#traversals-2)                               |
| 7    | February 27 | [Network Flow](#network-flow)                               |
|      | March 1     | [Prime Numbers](#prime-numbers)                             |
| 8    | March 6     | [Combinatorics](#combinatorics)                             |
|      | March 8     | [GCD](#GCD)                                                 |
| 9    | March 20    | [Bit Manipulation](#bit-manipulation)                       |
|      | March 22    | [Traveling Sales Person](#tsp)                              |
| 11   | April 10    | [Edit Distance](#line-sweep)                                |


## Lectures {#lectures}


### Course Introduction {#course-introduction}

Welcome to Competitive Programming!  Today we will talk about the benefits of competitive programming, the course structure, and the tools we will
use in the course.


#### Slides {#slides}

-   [Course Introduction Slides](/slides/course-introduction.pdf)


#### Judge Links {#judge-links}

-   Register on [Code Forces](https://codeforces.com).  Your username **will be visible** to other students; you can create a "throwaway"
    account if you want just for this course.
    -   Once you are registered, join [the Class Group](https://codeforces.com/group/C1FCILxvRp/contests).  This is where your problems
        will be hosted.
-   Similarly, register on [VJudge.net](https://vjudge.net) and for the [Class Group](https://vjudge.net/group/uiuc-cs491-sp23).


### IO {#io}

The first thing your program needs to do is read in the test data and convert it to an internal structure.
There are several patterns that test cases follow, and you will need to handle each one a bit differently.
It all comes down to knowing how much data you are going to get.  There are three primary ways you find this out:

-   An explicit count
-   A special marker (like a terminating zero)
-   Simply getting an end-of-file

We will also talk about formatting options.

We don't have a video for this lecture, but here are some slides with all the content.


#### Slides {#slides}

-   [IO Slides](/slides/io.pdf)


### Standard Template Library {#standard-template-library}

Today we will discuss the standard template library for C++.  You don't have to use this for your own
programming, but we will use it in our examples so you should know how it all works.


#### Slides {#slides}

-   [STL Slides](/slides/standard-template-library.pdf)


### Complete Search {#complete-search}

Also knowns as "brute force"; this paradigm happens when there's nothing to do but check all the possible solutions.

BUT!!!  That doesn't mean that you can't be clever how you do it.


#### Slides {#slides}

-   [Complete Search Slides](/slides/complete-search.pdf)


### Divide and Conquer {#divide-and-conquer}

Divide and conquer allows you to split a problem up, usually eliminating half of the search space.


#### Slides {#slides}

-   [Divide and Conquer Slides](/slides/divide-and-conquer.pdf)


### Greedy Algorithms {#greedy-algorithms}


#### Slides {#slides}

-   [Greedy Algorithms Slides](/slides/greedy-algorithms.pdf)


### Dynamic Programming {#dynamic-programming}


#### Slides {#slides}

-   [Dynamic Programming Slides](/slides/dynamic-programming.pdf)


### Graph Representations {#graph-representations}


#### Slides {#slides}

-   [Graph Representation Slides](/slides/graph-representation.pdf)


### Single Source Shortest Path {#single-source-shortest-path}


#### Slides {#slides}

-   [BFS Shortest Path](/slides/bfs-shortest-path.pdf)
-   [Dijkstra's Shortest Path Algorithm](/slides/dijkstra-shortest-path.pdf)
-   [Bellman Ford and SPFA](/slides/bellman-ford-and-spfa.pdf)


### All Points Shortest Path {#single-source-shortest-path}


#### Slides {#slides}

-   [Floyd Warshall](/slides/floyd-warshall.pdf)


### Traversals 2 {#traversals-2}


#### Slides {#slides}

-   [Traversals 2](/slides/traversals-2.pdf)


### Network Flow {#network-flow}

The Edmonds-Karp algorithm is a popular and efficient algorithm used to solve the max-flow problem in network flow
theory. This algorithm is an extension of the Ford-Fulkerson algorithm, which is a simple algorithm for finding the
maximum flow in a network. The Edmonds-Karp algorithm uses a breadth-first search approach to find the shortest
augmenting path in the residual graph, making it faster and more efficient than the original Ford-Fulkerson algorithm.


#### Slides {#slides}

-   [Edmonds Karp](/slides/edmonds-karp.pdf)


### Prime Numbers {#prime-numbers}

Prime numbers are a familiar feature in mathematics, and often come up in competitive programming.  In this lecture
we will derive the Sieve of Erastosthenes, show how to factor large numbers, and discuss the practical limits to the
number of prime numbers we can generate during a contest.


#### Slides {#slides}

-   [Prime Numbers](/slides/prime-numbers.pdf)


### Combinatorics {#combinatorics}

Combinatorics is the branch of mathematics that deals with counting and arranging objects.  We will cover some of the
fundamental concepts in combinatorics, including binomial coefficients, permutations, and derangements.

Binomial coefficients, also known as binomials, are a tool for counting the number of ways that a given set of objects
can be arranged or selected. We will explain how to calculate binomial coefficients  to model different scenarios such
as flipping coins or selecting items from a set.

A permutation is a reordering of a set of items.  We will explain how to count the number of permutations and how to
generate all the permutations of a given set. Derangements are permutations where no element appears in its original
position.  We will examine how to calculate the number of derangements for a set and discuss its applications.


#### Slides {#slides}

-   [Combinatorics](/slides/combinatorics.pdf)


### GCD {#GCD}

GCD, or Greatest Common Divisor, is a mathematical concept that refers to the largest positive integer that divides two or more numbers without leaving a remainder.

In class we will derive Euclid's algorithm, an efficient way of computing GCD, as well as explore some of the properties of GCD you will want to know when solving
competitve programming problems.


#### Materials {#materials}

-   [GCD Handout](/handouts/gcd.pdf)


### Inclusion/Exclusion {#inclusion-exclusion}

The principle of inclusion/exclusion is a counting technique used to calculate the size of a union of sets. It states that:

\\(|A \cup B \cup C| = |A| + |B| + |C| - |A \cap B| - |B \cap C| - |A \cap C| + |A \cap B \cap C|\\)

where \\(A\\), \\(B\\), and \\(C\\) are any finite sets.

In other words, to find the size of the union of three sets \\(A\\), \\(B\\), and \\(C\\), you first add the sizes of each set
individually, then subtract the sizes of the overlaps \\((A \cap B, B \cap C\\), and \\(A \cap C\\)), and finally add the size of the
triple overlap \\((A \cap B \cap C)\\).

This principle can be extended to any number of sets, and is a useful tool in combinatorics, probability theory, and
other areas of mathematics.


#### Materials {#materials}

-   [Inclusion-Exclusion Slides](/slides/inclusion-exclusion.pdf)


### Bit Manipulation {#bit-manipulation}


#### Materials {#materials}

-   [Slides](/slides/bit-manipulations.pdf)


### Traveling Sales Person {#tsp}

The Traveling Salesperson Problem (TSP) is a well-known problem in computer science and operations research that asks
for the shortest possible route that visits every city exactly once and returns to the starting city.  TSP has many
practical applications, including in logistics, transportation planning, and circuit board design.


#### Materials {#materials}

-   [Handout](/handouts/tsp-handout.pdf)
-   [Slides](/slides/tsp-slides.pdf)


### Fast Exponentiation {#fast-exponentiation}

Exponents are fun, but using bit techniques we covered last time we can compute them significantly faster than the standard technique.
This generalizes to other forms as well, such as computing Fibonacci numbers is sub-linear time.


#### Materials {#materials}

-   [Slides](/slides/fast-exponentiation.pdf)


### Points, Lines, and Vectors {#points-lines-vectors}


#### Materials {#materials}

-   [Slides](/slides/points-lines-vectors-slides.pdf)


### Line Sweep {#line-sweep}


#### Materials {#materials}

-   [Line Sweep Convex Hull](#line-sweep-convex-hull) Video
-   [Line Sweep Closest Points](#line-sweep-closest-points) Video
-   [Line Sweep Area of Union](#line-sweep-area-of-union) Video


### Rotating Calipers {#rotating-calipers}

```c++ { linenos=true, linenostart=1 }
function dist(p1,p2,p) {

  var A = p.x - p1.x;
  var B = p.y - p1.y;
  var C = p2.x - p1.x;
  var D = p2.y - p1.y;

  var dot = A * C + B * D;
  var len_sq = C * C + D * D;
  var param = -1;
  if (len_sq != 0) //in case of 0 length line
      param = dot / len_sq;

  var xx, yy;

  if (param < 0) {
    xx = p1.x;
    yy = p1.y;
  }
  else if (param > 1) {
    xx = p1.x;
    yy = p1.y;
  }
  else {
    xx = p1.x + param * C;
    yy = p1.y + param * D;
  }

  var dx = p.x - xx;
  var dy = p.y - yy;
  return Math.sqrt(dx * dx + dy * dy);
}

// Rotating Calipers Code

vector<point> p;

int n; // number of points

typedef pair<point,point> pp;

set<pp> antipodes;

int k=1;

while (dist(p[n-1],p[0],p[k+1]) > dist(p[n-1],p[1],p[k])
    ++k;

int i=1;
int j=k;

while (i <= k && j < n) {
  antipodes.add(pp(p[i],p[k]));
  while (dist(p[i],p[i+1],p[j+1]) > dist(p[i],p[i+1],p[j]) && j<m) {
     antipodes.add(pp(p[i],p[j]));
     ++j;
  }
  ++i;
}
```


### Edit Distance {#line-sweep}

Today we will talk about a classic string DP problem, determining the edit distance
between two strings.


#### Materials {#materials}

-   [Slides](/slides/edit-distance-slides.pdf)
-   [Edit Distance Video](#edit-distance)
